---
title: 안전지대
date : 2023-03-16
id : 안전지대
tag: 
   - coding-test
   - 구현
brand: blog
description: 기본적인 그래프 탐색문제를 해결하는 구현문제입니다.
---

## 문제 출처
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/120866" target="_blank" className="source">안전지대</a>

## 문제설명
<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/124a2c93-da99-4643-96a8-292bb871f553/image.png" alt="img" />

다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다.
지뢰는 2차원 배열 board에 1로 표시되어 있고 board에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다.
지뢰가 매설된 지역의 지도 board가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요.

## 제한사항
board는 n * n 배열입니다.
1 ≤ n ≤ 100
지뢰는 1로 표시되어 있습니다.
board에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다.
### 입출력 예

| board | result |
| --- | --- |
| `[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]]` | 16 |
| `[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0]]` | 13 |
| `[[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]` | 0 |




### 입출력 예 설명
입출력 예 #1

(3, 2)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선 총 8칸은 위험지역입니다. 따라서 16을 return합니다.
입출력 예 #2

(3, 2), (3, 3)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선은 위험지역입니다. 따라서 위험지역을 제외한 칸 수 13을 return합니다.
입출력 예 #3

모든 지역에 지뢰가 있으므로 안전지역은 없습니다. 따라서 0을 return합니다.

# 의사코드 작성

1.  **배열의 크기를 구한다.**
2. **1이 위치한 인덱스를 모두 찾는다.**
3. **1이 위치한 인덱스에서 위험지역의 개수를 구한다.**
4. **위험 지역과 1의 개수를 빼서 안전 구역을 구한다.** 

# 코딩 구현

- 배열의 크기를 구한다.
    
    ```jsx
    const { length } = board;
    const totalSize = board.length * board[0].length;
    ```
    
- 1위 위치한 인덱스를 모두 구한다.
    
    ```jsx
      for (let i = 0; i < length; i++) {
        for (let j = 0; j < length; j++) {
          if (board[i][j] === 1) {
            one.push([i, j]);
            oneCount += 1;
          }
        }
      }
    ```
    
- **1이 위치한 인덱스에서 위험지역의 개수를 구한다.**
    - 1이 인접한 위치에 있을 경우 중복 체크 되는 경우를 배제 해야 한다.
    - 1의 인접 지역이 board의 크기를 벗어나는 경우를 제외해야 한다.
        
        ```jsx
         // 위험 구역 찾기
          for (let i = 0; i < one.length; i++) {
            const hori = one[i][0];
            const verti = one[i][1];
            for (let x = hori - 1; x <= hori + 1; x++) {
              if (x < 0 || x >= length) continue;
              for (let y = verti - 1; y <= verti + 1; y++) {
                // x 좌표와 y 좌표가 0보다 작서나 board 크기를 벗어나는 경우 제외
                if (y < 0 || y >= length) continue;
                if (board[x][y] !== 1 && check(danger,x,y)) danger.push([x,y]);
              }
            }
          }
        ```
        
    - 2중 배열을 사용하였기에 기존의 `Array.prototype.includes()` 혹은 `Array.prototype.indexOf()` 를 통해서 중복된 값이 들어왔는지 확인이 불가능하다. 배열은 참조 자료형이기 때문에, 모양이 똑같아도 서로 다른 메모리 주소를 가지고 있다. 따라서 값의 일치 여부를 확인하는 함수 `check` 를 만들어 이를 해결했다.
        
        ```jsx
        function check(list, x, y) {
          const { length } = list;
          if (length === 0) return true;
          let check = true;
          for (let i = 0; i < length; i++) {
            if (list[i][0] === x && list[i][1] === y) {
              check = false;
              break;
            }
          }
          return check;
        }
        ```
        
- 위험 지역과 1의 개수를 빼서 안전 구역을 구한다.
    
    ```jsx
    return totalSize - one.length - danger.length
    ```
    
- 전체 소스 코드
    
    ```jsx
    function check(list, x, y) {
      const { length } = list;
      if (length === 0) return true;
      let check = true;
      for (let i = 0; i < length; i++) {
        if (list[i][0] === x && list[i][1] === y) {
          check = false;
          break;
        }
      }
      return check;
    }
    
    function solution(board) {
      const { length } = board;
      const totalSize = board.length * board[0].length;
      const one = [];
      const danger = [];
      let oneCount = 0;
    
      // 1의 위치 파악하기
      for (let i = 0; i < length; i++) {
        for (let j = 0; j < length; j++) {
          if (board[i][j] === 1) {
            one.push([i, j]);
            oneCount += 1;
          }
        }
      }
      //모두 지뢰로 가득 차 있을 경우우
      if (oneCount === totalSize) return 0;
    
      // 위험 구역 찾기
      for (let i = 0; i < one.length; i++) {
        const hori = one[i][0];
        const verti = one[i][1];
        for (let x = hori - 1; x <= hori + 1; x++) {
          if (x < 0 || x >= length) continue;
          for (let y = verti - 1; y <= verti + 1; y++) {
            // x 좌표와 y 좌표가 0보다 작서나 board 크기를 벗어나는 경우 제외
            if (y < 0 || y >= length) continue;
            if (board[x][y] !== 1 && check(danger,x,y)) danger.push([x,y]);
          }
        }
      }
      return totalSize - one.length - danger.length
    }
    ```
    

# 어려웠던 점

- 배열이 참조 자료형이기에 단순 비교로는 배열 내의 포함 여부를 확인하기 어렵다는 점을 놓치고 있었다. 이 부분에서 많은 시간을 할애했다.
- board의 크기를 벗어난 경우를 제외하는 과정에서 대소비교를 잘못했다는 점을 놓치고 있었다. 지곤 board.length보다 작은 경우만 포함이 되는데, board.length와 같은 경우를 포함해서 문제가 발생했다.
- 너무 많은 반복문의 활용으로 코드가 어지럽다. 이를 정리할 필요가 있다.

# 대안 코드

- check 함수를 활용하지 않고 JONS.parse()를 활용한 깊은 복사를 통해 좀 더 쉽게 해결할 수 있다.
```js
function solution(board) {
  const { length } = board;
  const totalSize = board.length * board[0].length;
  const one = [];
  const danger = JSON.parse(JSON.stringify(board));
  let oneCount = 0;

  // 1의 위치 파악하기
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      if (board[i][j] === 1) {
        one.push([i, j]);
        oneCount += 1;
      }
    }
  }
  //모두 지뢰로 가득 차 있을 경우우
  if (oneCount === totalSize) return 0;

  // 위험 구역 찾기
  for (let i = 0; i < one.length; i++) {
    const hori = one[i][0];
    const verti = one[i][1];
    for (let x = hori - 1; x <= hori + 1; x++) {
      if (x < 0 || x >= length) continue;
      for (let y = verti - 1; y <= verti + 1; y++) {
        // x 좌표와 y 좌표가 0보다 작서나 board 크기를 벗어나는 경우 제외
        if (y < 0 || y >= length) continue;
        if (board[x][y] !== 1) danger[x][y] = -1;
      }
    }
  }
  return danger.flat().filter(item=>item===0).length
}
```